<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="함수형 프로그래밍과 자바 진화의 미래 #  18장 함수형 광점으로 생각하기 #  18.1 시스템 구현과 유지보수
18.1.1 공유된 가변 데이터
- 여러 클래스에서 공유하는 가변 데이터는 어느 클래스가 소유자인지 구분하기 어렵다. - 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 Side-Effect Free 메서드라고 한다. - 불변 객체를 통해서 부작용을 없앴 수 있다. 18.1.2 선언형 프로그래밍
- 어떻게에 집중하는 방식은 명령형 프로그래밍으로 고전적인 객체지향 프로그래밍이에서 이용하는 방식 - 무엇을에 집중하는 방식은 선언형 프로그래밍으로 구현 방법은 질의문을 내부 반복으로 수행한다."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Part5. 함수형 프로그래밍과 자바 진화의 미래"><meta property="og:description" content="함수형 프로그래밍과 자바 진화의 미래 #  18장 함수형 광점으로 생각하기 #  18.1 시스템 구현과 유지보수
18.1.1 공유된 가변 데이터
- 여러 클래스에서 공유하는 가변 데이터는 어느 클래스가 소유자인지 구분하기 어렵다. - 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 Side-Effect Free 메서드라고 한다. - 불변 객체를 통해서 부작용을 없앴 수 있다. 18.1.2 선언형 프로그래밍
- 어떻게에 집중하는 방식은 명령형 프로그래밍으로 고전적인 객체지향 프로그래밍이에서 이용하는 방식 - 무엇을에 집중하는 방식은 선언형 프로그래밍으로 구현 방법은 질의문을 내부 반복으로 수행한다."><meta property="og:type" content="article"><meta property="og:url" content="https://sogmy.github.io/docs/java/mordern_java_in_action/part6/"><meta property="article:section" content="docs"><title>Part5. 함수형 프로그래밍과 자바 진화의 미래 | Sogmy Devlog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.e246e6a45b940b6ff71d8216783f10a80d910290a7c364c8bfd5d305d8545d62.css integrity="sha256-4kbmpFuUC2/3HYIWeD8QqA2RApCnw2TIv9XTBdhUXWI="><script defer src=/en.search.min.6b49ae984c7fa3871e68ff8a972d3588e760fc6455c4c31080da400ba4124896.js integrity="sha256-a0mumEx/o4ceaP+Kly01iOdg/GRVxMMQgNpAC6QSSJY="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><span>Sogmy Devlog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Java</span><ul><li><a href=https://sogmy.github.io/docs/java/java_convert_interger_list/>Java Convert Interger List</a></li><li><a href=https://sogmy.github.io/docs/java/java_map_iterate/>Java Map to Iterate</a></li><li><a href=https://sogmy.github.io/docs/java/javatype/>Primitive type, Reference type</a></li><li><input type=checkbox id=section-c7aeb586f4bfe724a4d2397888671ae7 class=toggle checked>
<label for=section-c7aeb586f4bfe724a4d2397888671ae7 class="flex justify-between"><a>Mordern Java in Action</a></label><ul><li><a href=https://sogmy.github.io/docs/java/mordern_java_in_action/part1/>Part 1. 기초</a></li><li><a href=https://sogmy.github.io/docs/java/mordern_java_in_action/part2/>Part2. 함수형 데이터 처리</a></li><li><a href=https://sogmy.github.io/docs/java/mordern_java_in_action/part3/>Part3. 스트림과람다</a></li><li><a href=https://sogmy.github.io/docs/java/mordern_java_in_action/part5/>Part5. 개선된 자바 동시성</a></li><li><a href=https://sogmy.github.io/docs/java/mordern_java_in_action/part6/ class=active>Part5. 함수형 프로그래밍과 자바 진화의 미래</a></li></ul></li><li><span>Ect</span><ul><li><a href=https://sogmy.github.io/docs/java/ect/java_string_method/>String Method</a></li><li><a href=https://sogmy.github.io/docs/java/ect/javax_valid/>javax @Valid</a></li></ul></li></ul></li><li class=book-section-flat><span>Spring</span><ul></ul></li><li class=book-section-flat><span>Database</span><ul></ul></li><li class=book-section-flat><span>Infra</span><ul><li><a href=https://sogmy.github.io/docs/infra/scale_up_scale_out/>Scale-up, Scale-out</a></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Part5. 함수형 프로그래밍과 자바 진화의 미래</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#18장-함수형-광점으로-생각하기>18장 함수형 광점으로 생각하기</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=함수형-프로그래밍과-자바-진화의-미래>함수형 프로그래밍과 자바 진화의 미래
<a class=anchor href=#%ed%95%a8%ec%88%98%ed%98%95-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d%ea%b3%bc-%ec%9e%90%eb%b0%94-%ec%a7%84%ed%99%94%ec%9d%98-%eb%af%b8%eb%9e%98>#</a></h1><h3 id=18장-함수형-광점으로-생각하기>18장 함수형 광점으로 생각하기
<a class=anchor href=#18%ec%9e%a5-%ed%95%a8%ec%88%98%ed%98%95-%ea%b4%91%ec%a0%90%ec%9c%bc%eb%a1%9c-%ec%83%9d%ea%b0%81%ed%95%98%ea%b8%b0>#</a></h3><p><strong>18.1 시스템 구현과 유지보수</strong></p><p>18.1.1 공유된 가변 데이터</p><pre><code>- 여러 클래스에서 공유하는 가변 데이터는 어느 클래스가 소유자인지 구분하기 어렵다.
- 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 Side-Effect Free 메서드라고 한다.
- 불변 객체를 통해서 부작용을 없앴 수 있다.
</code></pre><p>18.1.2 선언형 프로그래밍</p><pre><code>- 어떻게에 집중하는 방식은 명령형 프로그래밍으로 고전적인 객체지향 프로그래밍이에서 이용하는 방식
- 무엇을에 집중하는 방식은 선언형 프로그래밍으로 구현 방법은 질의문을 내부 반복으로 수행한다. 
- 선언형 프로그래밍은 질의문 자체로 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다.
</code></pre><p>18.1.3 왜 함수형 프로그래밍인가?</p><pre><code>- 함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며 부작용이 없는 계산을 지향한다. 
</code></pre><p><strong>18.2 함수형 프로그래밍이란 무엇인가?</strong></p><blockquote><p>함수를 이용하는 프로그래밍으로 함수의 의미는 수학적인 함수와 같다. 0개 이상의 인수를 가지며 한개 이상의 결과를 반환하지만 부작용(side-effect)이 없어야 한다.</p></blockquote><blockquote><p>시스템의 다른 부분의 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능을 사용하는 방식을 함수형 프로그래밍이라 한다.</p></blockquote><p>18.2.1 함수형 자바</p><pre><code>실질적으로 자바는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다.
1. 함수나 메서드는 지역 변수만을 변경해야 함수형이라고 할 수 있다.
2. 모든 객체는 불변 객체여야 한다.
3. 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.
4. 수학정 함수는 주어진 인수에 하나의 값을 반환한다.
5. 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야한다.
</code></pre><p>18.2.2 참조 투명성</p><pre><code>- `부작용은 감춰야한다` 라는 제약은 참조 투명성 (referential transparency) 개념으로 귀결된다.
- 같은 인수이면 같은 결과값을 반환해야 한다.
- List 같은 경우 같은 두번의 호출로 같은 요소를 포함하지만 메모리 공간은 다른 곳에 생성된다. 불변의 순수 값을 사용할 것이라면 참조적으로 투명한 것으로 간주 한다.
</code></pre><p>18.2.3 객체지향 프로그래밍과 함수형 프로그래밍</p><pre><code>자바는 익스트림 객체지향 방식과 함수형 방식을 모두 취한다.
</code></pre><p><strong>18.3 재귀와 반복</strong></p><blockquote><p>순수 함수형 프로그래밍 언어에서는 while, for 같은 반복문을 사용하지 않는다.</p></blockquote><p>팩토리얼 예제</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>factorialIterative</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> n<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
        r <span style=color:#f92672>*=</span> i<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>return</span> r<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>factorialRecusive</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> n <span style=color:#f92672>==</span> 1 <span style=color:#f92672>?</span> 1 <span style=color:#f92672>:</span> n <span style=color:#f92672>*</span> factorialRecusive<span style=color:#f92672>(</span>n<span style=color:#f92672>-</span>1<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>factorialSteames</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> LongSteream<span style=color:#f92672>.</span><span style=color:#a6e22e>rangeClosed</span><span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> n<span style=color:#f92672>)</span>
                      <span style=color:#f92672>.</span><span style=color:#a6e22e>reduce</span><span style=color:#f92672>(</span>1<span style=color:#f92672>,(</span><span style=color:#66d9ef>long</span> a<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> b<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>*</span> b<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>꼬리 재귀 팩토리얼</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>factorialTailRecusive</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> factorialHelper<span style=color:#f92672>(</span>1<span style=color:#f92672>,</span>n<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>fcatorialHelper</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> acc<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> n <span style=color:#f92672>==</span> 1 <span style=color:#f92672>?</span> acc <span style=color:#f92672>:</span> factorialHelper<span style=color:#f92672>(</span>acc <span style=color:#f92672>*</span> n <span style=color:#f92672>,</span> n <span style=color:#f92672>-</span>1<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>중간 값을 각자의 스택 프레임으로 저장해야하는 일반 재귀와 달리 꼬리 재귀는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 있으나 자바에서는 지원하지 않는다.(스칼라 그루비 같은 jvm 언어는 이와 같은 재귀 반복을 최적화 한다.)</p><blockquote><ul><li>공유 가변 자료구조를 줄이는 것은 장기적으로 프로그램 유지보수하고 디버깅하는 데 도움이 된다.</li><li>함수형 프로그래밍은 부작용이 없는 메서드와 선언형 프로그래밍 방식을 지향한다.</li><li>함수형 메서드는 입력 인수와 출력 결과만을 갖는다.</li><li>같은 인수 값으로 함수를 호출했을 때 항상 같은 값을 반환하면 참조 투명성을 갖는 함수다. while 루프 같은 반복움능 재귀로 대체할 수 있다.</li><li>자바에서는 고전 방식의 재귀보다 꼬리 재귀를 사용해야 추가적인 컴파일러 최적화를 기대할 수 있다.</li></ul></blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#18장-함수형-광점으로-생각하기>18장 함수형 광점으로 생각하기</a></li></ul></li></ul></nav></div></aside></main></body></html>