<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="함수형 프로그래밍과 자바 진화의 미래 # 18장 함수형 관점으로 생각하기 # 18.1 시스템 구현과 유지보수
18.1.1 공유된 가변 데이터
여러 클래스에서 공유하는 가변 데이터는 어느 클래스가 소유자인지 구분하기 어렵다. 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 Side-Effect Free 메서드라고 한다. 불변 객체를 통해서 부작용을 없앴 수 있다. 18.1.2 선언형 프로그래밍
어떻게에 집중하는 방식은 명령형 프로그래밍으로 고전적인 객체지향 프로그래밍이에서 이용하는 방식 무엇을에 집중하는 방식은 선언형 프로그래밍으로 구현 방법은 질의문을 내부 반복으로 수행한다."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Part5. 함수형 프로그래밍과 자바 진화의 미래"><meta property="og:description" content="함수형 프로그래밍과 자바 진화의 미래 # 18장 함수형 관점으로 생각하기 # 18.1 시스템 구현과 유지보수
18.1.1 공유된 가변 데이터
여러 클래스에서 공유하는 가변 데이터는 어느 클래스가 소유자인지 구분하기 어렵다. 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 Side-Effect Free 메서드라고 한다. 불변 객체를 통해서 부작용을 없앴 수 있다. 18.1.2 선언형 프로그래밍
어떻게에 집중하는 방식은 명령형 프로그래밍으로 고전적인 객체지향 프로그래밍이에서 이용하는 방식 무엇을에 집중하는 방식은 선언형 프로그래밍으로 구현 방법은 질의문을 내부 반복으로 수행한다."><meta property="og:type" content="article"><meta property="og:url" content="https://seoah-lab.github.io/docs/java/mordern_java_in_action/part6/"><meta property="article:section" content="docs"><title>Part5. 함수형 프로그래밍과 자바 진화의 미래 | Dev Log</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.e246e6a45b940b6ff71d8216783f10a80d910290a7c364c8bfd5d305d8545d62.css integrity="sha256-4kbmpFuUC2/3HYIWeD8QqA2RApCnw2TIv9XTBdhUXWI="><script defer src=/en.search.min.137035a8f5fb6533070ce5a1782712389cd83053bda70b8a945e7335c6b4be2d.js integrity="sha256-E3A1qPX7ZTMHDOWheCcSOJzYMFO9pwuKlF5zNca0vi0="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><span>Dev Log</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Java</span><ul><li><input type=checkbox id=section-c0c7b610f24430052fb75d6894b0c1fc class=toggle>
<label for=section-c0c7b610f24430052fb75d6894b0c1fc class="flex justify-between"><a>Basic</a></label><ul><li><a href=https://seoah-lab.github.io/docs/java/basic/java_convert_interger_list/>Java Convert Interger List</a></li><li><a href=https://seoah-lab.github.io/docs/java/basic/java_map_iterate/>Java Map to Iterate</a></li><li><a href=https://seoah-lab.github.io/docs/java/basic/java_string_method/>Java String Method</a></li><li><a href=https://seoah-lab.github.io/docs/java/basic/javatype/>Primitive type, Reference type</a></li><li><a href=https://seoah-lab.github.io/docs/java/basic/java_charter/>Java Charter</a></li><li><a href=https://seoah-lab.github.io/docs/java/basic/java_map_sort/>Java Map Sort</a></li><li><a href=https://seoah-lab.github.io/docs/java/basic/java_math/>Java Math</a></li><li><a href=https://seoah-lab.github.io/docs/java/basic/javax_valid/>javax @Valid</a></li></ul></li><li><input type=checkbox id=section-c7aeb586f4bfe724a4d2397888671ae7 class=toggle checked>
<label for=section-c7aeb586f4bfe724a4d2397888671ae7 class="flex justify-between"><a>Mordern Java in Action</a></label><ul><li><a href=https://seoah-lab.github.io/docs/java/mordern_java_in_action/part1/>Part 1. 기초</a></li><li><a href=https://seoah-lab.github.io/docs/java/mordern_java_in_action/part2/>Part2. 함수형 데이터 처리</a></li><li><a href=https://seoah-lab.github.io/docs/java/mordern_java_in_action/part3/>Part3. 스트림과람다</a></li><li><a href=https://seoah-lab.github.io/docs/java/mordern_java_in_action/part5/>Part5. 개선된 자바 동시성</a></li><li><a href=https://seoah-lab.github.io/docs/java/mordern_java_in_action/part6/ class=active>Part5. 함수형 프로그래밍과 자바 진화의 미래</a></li></ul></li></ul></li><li class=book-section-flat><span>Spring</span><ul><li><a href=https://seoah-lab.github.io/docs/spring/life_cycle/>Life Cycle</a></li></ul></li><li class=book-section-flat><span>Database</span><ul><li><a href=https://seoah-lab.github.io/docs/database/mysql_index/>Mysql Index</a></li><li><a href=https://seoah-lab.github.io/docs/database/mysql_trainsaction_level/>Mysql Trainsaction Level</a></li></ul></li><li class=book-section-flat><span>Infra</span><ul><li><a href=https://seoah-lab.github.io/docs/infra/scale_up_scale_out/>Scale-up, Scale-out</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Part5. 함수형 프로그래밍과 자바 진화의 미래</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#18장-함수형-관점으로-생각하기>18장 함수형 관점으로 생각하기</a></li><li><a href=#19장-함수형-프로그래밍-기법>19장 함수형 프로그래밍 기법</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=함수형-프로그래밍과-자바-진화의-미래>함수형 프로그래밍과 자바 진화의 미래
<a class=anchor href=#%ed%95%a8%ec%88%98%ed%98%95-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d%ea%b3%bc-%ec%9e%90%eb%b0%94-%ec%a7%84%ed%99%94%ec%9d%98-%eb%af%b8%eb%9e%98>#</a></h1><h3 id=18장-함수형-관점으로-생각하기>18장 함수형 관점으로 생각하기
<a class=anchor href=#18%ec%9e%a5-%ed%95%a8%ec%88%98%ed%98%95-%ea%b4%80%ec%a0%90%ec%9c%bc%eb%a1%9c-%ec%83%9d%ea%b0%81%ed%95%98%ea%b8%b0>#</a></h3><p><strong>18.1 시스템 구현과 유지보수</strong></p><p>18.1.1 공유된 가변 데이터</p><pre tabindex=0><code>여러 클래스에서 공유하는 가변 데이터는 어느 클래스가 소유자인지 구분하기 어렵다.
자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 
return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 Side-Effect Free 메서드라고 한다.
불변 객체를 통해서 부작용을 없앴 수 있다.
</code></pre><p>18.1.2 선언형 프로그래밍</p><pre tabindex=0><code>어떻게에 집중하는 방식은 명령형 프로그래밍으로 고전적인 객체지향 프로그래밍이에서 이용하는 방식
무엇을에 집중하는 방식은 선언형 프로그래밍으로 구현 방법은 질의문을 내부 반복으로 수행한다. 
선언형 프로그래밍은 질의문 자체로 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다.
</code></pre><p>18.1.3 왜 함수형 프로그래밍인가?</p><pre tabindex=0><code>함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며 부작용이 없는 계산을 지향한다. 
</code></pre><p><strong>18.2 함수형 프로그래밍이란 무엇인가?</strong></p><blockquote><p>함수를 이용하는 프로그래밍으로 함수의 의미는 수학적인 함수와 같다.
0개 이상의 인수를 가지며 한개 이상의 결과를 반환하지만 부작용(side-effect)이 없어야 한다.
시스템의 다른 부분의 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능을 사용하는 방식을 함수형 프로그래밍이라 한다.</p></blockquote><p>18.2.1 함수형 자바</p><pre tabindex=0><code>실질적으로 자바는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다.
1. 함수나 메서드는 지역 변수만을 변경해야 함수형이라고 할 수 있다.
2. 모든 객체는 불변 객체여야 한다.
3. 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.
4. 수학정 함수는 주어진 인수에 하나의 값을 반환한다.
5. 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야한다.
</code></pre><p>18.2.2 참조 투명성</p><pre tabindex=0><code>`부작용은 감춰야한다` 라는 제약은 참조 투명성 (referential transparency) 개념으로 귀결된다.
같은 인수이면 같은 결과값을 반환해야 한다.
List 같은 경우 같은 두번의 호출로 같은 요소를 포함하지만 메모리 공간은 다른 곳에 생성된다. 
불변의 순수 값을 사용할 것이라면 참조적으로 투명한 것으로 간주 한다.
</code></pre><p>18.2.3 객체지향 프로그래밍과 함수형 프로그래밍</p><pre tabindex=0><code>자바는 익스트림 객체지향 방식과 함수형 방식을 모두 취한다.
</code></pre><p><strong>18.3 재귀와 반복</strong></p><blockquote><p>순수 함수형 프로그래밍 언어에서는 while, for 같은 반복문을 사용하지 않는다.</p></blockquote><p>팩토리얼 예제</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>factorialIterative</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> n<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>*=</span> i<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> r<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>factorialRecusive</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> n <span style=color:#f92672>==</span> 1 <span style=color:#f92672>?</span> 1 <span style=color:#f92672>:</span> n <span style=color:#f92672>*</span> factorialRecusive<span style=color:#f92672>(</span>n<span style=color:#f92672>-</span>1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>factorialSteames</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> LongSteream<span style=color:#f92672>.</span><span style=color:#a6e22e>rangeClosed</span><span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> n<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                      <span style=color:#f92672>.</span><span style=color:#a6e22e>reduce</span><span style=color:#f92672>(</span>1<span style=color:#f92672>,(</span><span style=color:#66d9ef>long</span> a<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> b<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>*</span> b<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>꼬리 재귀 팩토리얼</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>factorialTailRecusive</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> factorialHelper<span style=color:#f92672>(</span>1<span style=color:#f92672>,</span>n<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>fcatorialHelper</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> acc<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> n <span style=color:#f92672>==</span> 1 <span style=color:#f92672>?</span> acc <span style=color:#f92672>:</span> factorialHelper<span style=color:#f92672>(</span>acc <span style=color:#f92672>*</span> n <span style=color:#f92672>,</span> n <span style=color:#f92672>-</span>1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>중간 값을 각자의 스택 프레임으로 저장해야하는 일반 재귀와 달리 꼬리 재귀는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 있으나 자바에서는 지원하지 않는다.(스칼라 그루비 같은 jvm 언어는 이와 같은 재귀 반복을 최적화 한다.)</p><blockquote><ul><li>공유 가변 자료구조를 줄이는 것은 장기적으로 프로그램 유지보수하고 디버깅하는 데 도움이 된다.</li><li>함수형 프로그래밍은 부작용이 없는 메서드와 선언형 프로그래밍 방식을 지향한다.</li><li>함수형 메서드는 입력 인수와 출력 결과만을 갖는다.</li><li>같은 인수 값으로 함수를 호출했을 때 항상 같은 값을 반환하면 참조 투명성을 갖는 함수다.</li><li>while 루프 같은 반복움능 재귀로 대체할 수 있다.</li><li>자바에서는 고전 방식의 재귀보다 꼬리 재귀를 사용해야 추가적인 컴파일러 최적화를 기대할 수 있다.</li></ul></blockquote><h3 id=19장-함수형-프로그래밍-기법>19장 함수형 프로그래밍 기법
<a class=anchor href=#19%ec%9e%a5-%ed%95%a8%ec%88%98%ed%98%95-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ea%b8%b0%eb%b2%95>#</a></h3><p>19.1 함수는 모든 곳에 존재한다.
자바 8부터는 함수도 일급으로 참조할 수 있다.</p><p>19.1.1 고차원 함수</p><pre tabindex=0><code>Comparator.comparing 정적메소드과 같이 다음과 같은 기능을 하나이상하는 함수를 고차원함수라고 한다.
하나 이상의 함수를 인수로 받음
함수를 결과로 반환
</code></pre><p>함수를 인수로 전달결과 반환 지역변수로 할당 구조체로 삽입할 수 있으므로 자바의 함수도 고차원 함수라고 할수 있다.
고차원 함수를 사용할 때 함수에서 어떤 언지가 사용되고 예상 못한 결과가 발생할 수 있다.
고차원 함수 구현시 사이드 이팩트를 고려해야 한다.</p><p>19.1.2 커링 (Currying)</p><pre tabindex=0><code>Currying은 여러 개의 인자를 가진 함수를 호출 할 경우
파라미터의 수보다 적은 수의 파라미터를 인자로 받으면 누락된 파라미터를 인자로 받는 기법을 말한다.
부분적으로 적용된 함수를 체인으로 계속 생성해 결과적으로 값을 처리하도록 하는 것이 그 본질이다.
</code></pre><p>19.2 영속 자료구조
19.2.1 파과적인 갱신과 함수형</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#18장-함수형-관점으로-생각하기>18장 함수형 관점으로 생각하기</a></li><li><a href=#19장-함수형-프로그래밍-기법>19장 함수형 프로그래밍 기법</a></li></ul></li></ul></nav></div></aside></main></body></html>