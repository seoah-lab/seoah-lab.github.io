<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on SOGMY DOCS</title><link>https://sogmy.github.io/</link><description>Recent content in Introduction on SOGMY DOCS</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://sogmy.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://sogmy.github.io/docs/java/convert_interger_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sogmy.github.io/docs/java/convert_interger_list/</guid><description>Convert Integer List to Int Array in Java # List 의 toArray() 메서드는 Object 타입을 지원한다. 즉 int[] 배열은 지원하지 않는다.
ArrayList toArray() # public Object[] toArray() or public &amp;lt;T&amp;gt; T[] toArray(T[] a) import java.io.*; import java.util.List; import java.util.ArrayList; class Main { public static void main(String[] args) { List&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;Integer&amp;gt;(); al.add(10); al.add(20); al.add(30); al.add(40); Object[] objects = al.toArray(); // Printing array of objects for (Object obj : objects) System.</description></item><item><title/><link>https://sogmy.github.io/docs/java/ect/java_string_method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sogmy.github.io/docs/java/ect/java_string_method/</guid><description>String Method # String.IndexOf()
String.LastIndexOf()
String.length()
String.contains()
String.toCharArray()
String.replace()
String.replaceAll()
String.toLowCase()
String.toUpperCase()
String.substring()</description></item><item><title>Map to Iterate</title><link>https://sogmy.github.io/docs/java/map_iterate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sogmy.github.io/docs/java/map_iterate/</guid><description>Map to Iterate # HashMap 의 key 와 value를 확인할때 활용할 수 있는 방법은 다음과 같다.
import java.util.Map; import java.util.HashMap; class Iteration { public static void main(String[] arg) { Map&amp;lt;String,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); // enter name/url pair map.put(&amp;#34;sogmy&amp;#34;, 1); map.put(&amp;#34;hyunjin&amp;#34;, 2); map.put(&amp;#34;suji&amp;#34;, 3); map.put(&amp;#34;young&amp;#34;, 4); map.put(&amp;#34;ki&amp;#34;, 5); Iterator&amp;lt;Map.Entry&amp;lt;String, Interger&amp;gt;&amp;gt; itr = map.entrySet().iterator(); while(itr.hasNext()) { Map.Entry&amp;lt;String, Interger&amp;gt; entry = itr.next(); System.out.println(&amp;#34;Key = &amp;#34; + entry.getKey() + &amp;#34;, Value = &amp;#34; + entry.</description></item><item><title>Part 1. 기초</title><link>https://sogmy.github.io/docs/java/mordern_java_in_action/part1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sogmy.github.io/docs/java/mordern_java_in_action/part1/</guid><description>1 장 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가? # 스트림 API
스트림이란? 한번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임
스트림의 특징
스레드를 직접 구현하지 않으면서도 멀티스레딩 shared mutable data 에 접근하지 않고 안전한 코드 실행 반복적인 코드 블록으로 인한 외부 반복에서 내부 반복으로 전환함 메서드에 코드르 전달하는 기법
동작의 파라미터화 (메서드를 전달함)
메서드를 일급으로 함수를 일급으로
메서드참조 (method reference)</description></item><item><title>Part2. 함수형 데이터 처리</title><link>https://sogmy.github.io/docs/java/mordern_java_in_action/part2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sogmy.github.io/docs/java/mordern_java_in_action/part2/</guid><description>Part2. 함수형 데이터 처리 # 4장 스트림 소개 # 스트림이란 무엇인가 Stream 자바 8 API 새로 추가된 기능이다.
자바 7의 코드
List&amp;lt;Dish&amp;gt; lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;(); for(Dish dish: menu) { if(dish.getCalories() &amp;lt; 400) { lowCaloricDishes.add(dish); } } Collections.sort(lowCaloricdishes, new Comparator&amp;lt;Dish&amp;gt;() { // 익명 클래스로 요리 정렬 pulbic int compare(Dish dish1, Dish dish2) { return Integer.compare(dish1.getCalories(), dish2.getCalories()); } }); List&amp;lt;String&amp;gt; lowCaloricDishesName = new ArrayList(); for(DIsh dish: lowCaloricDishes) { lowCaloricDishesName.</description></item><item><title>Part3. 스트림과람다...</title><link>https://sogmy.github.io/docs/java/mordern_java_in_action/part3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sogmy.github.io/docs/java/mordern_java_in_action/part3/</guid><description>Part3. 스트림과 람다를 이용한 효과적인 프로그래밍 # 8장 컬렉션 API 개선 # 컬렉션 팩토리
적은 요소를 가지고 있는 리스트를 생성
List&amp;lt;String&amp;gt; friends = Arrays.asList(&amp;#34;Rapheal&amp;#34;, &amp;#34;Olivia&amp;#34;); UnsupportedOperationException 내부적으로 고정된 크기의 변환할 수 있는 배열로 구현 되었기 때문에 발생한다.
집합을 생성
Set&amp;lt;String&amp;gt; friends = new HashSet&amp;lt;&amp;gt;(Arrays.asList(&amp;#34;Rapheael&amp;#34;, &amp;#34;Olivia&amp;#34;, &amp;#34;Thibaut&amp;#34;)); 스트림 API 로 집합을 생성
Set&amp;lt;String&amp;gt; friends = Stream.of(&amp;#34;Raphael&amp;#34;, &amp;#34;Olivia&amp;#34;, &amp;#34;THibat&amp;#34;).collect(Collectors.toSet()); 리스트 팩토리
List.of() 로 간단한 리스트 생성
ListM&amp;lt;String&amp;gt; friend = List.of(&amp;#34;Raphael&amp;#34;, &amp;#34;Olivia&amp;#34;, &amp;#34;Thibat&amp;#34;); List.</description></item><item><title>Primitive type, Reference type</title><link>https://sogmy.github.io/docs/java/javatype/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sogmy.github.io/docs/java/javatype/</guid><description>Primitive type, Reference type # 1. 기본형 (Primitive) # Primitive type은 논리형, 문자형, 정수형, 실수형으로 구분된다. blooean, byte, short, int, long , float, duble, char 8가지 이다. null 이 존재하지 않는다. waper class 가 존재한다. Stack 메모리에 저장된다. 컴파일 시점에 메모리의 크기를 초과하면 에러가 발생한다. (stack over flow) 2. 참조형 (Reference type) # 기본형 타입을 제외한 타입들이 모두 참조형 타입(Reference type)이다. java.lang.Object 상속 null 이 존재하며 어떤 객체 주소도 저장되어 있지 않음을 의미한다.</description></item><item><title>Scale-up, Scale-out</title><link>https://sogmy.github.io/docs/infra/scale_up_scale_out/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sogmy.github.io/docs/infra/scale_up_scale_out/</guid><description>Scale-up, Scale-out # 스케일업(Scale-up)은 단순히 말하자면 기존의 하드웨어를 보다 높은 사양으로 업그레이드하는 것을 말합니다.
스케일아웃(Scale-out)은 장비를 추가해서 확장하는 방식을 말합니다.
시스템 리소스를 확장하는 방법으로는 수평적으로 부하를 분산하는 스케일 아웃(scale out) 방식으로 확장을 할 지 아니면 해당 서버의 용량 자체를 올리는 스케일 업 (scale up) 방식으로 확장을 할지 선택해야 한다.</description></item></channel></rss>