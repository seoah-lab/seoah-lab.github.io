<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Dev Log</title><link>https://seoah-lab.github.io/</link><description>Recent content in Introduction on Dev Log</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://seoah-lab.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Java Map to Iterate</title><link>https://seoah-lab.github.io/docs/java/basic/java_map_iterate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/basic/java_map_iterate/</guid><description>Java Map to Iterate # HashMap 의 key 와 value를 확인할때 활용할 수 있는 방법은 다음과 같다.
import java.util.Map; import java.util.HashMap; class Iteration { public static void main(String[] arg) { Map&amp;lt;String,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); // enter name/url pair map.put(&amp;#34;sogmy&amp;#34;, 1); map.put(&amp;#34;hyunjin&amp;#34;, 2); map.put(&amp;#34;suji&amp;#34;, 3); map.put(&amp;#34;young&amp;#34;, 4); map.put(&amp;#34;ki&amp;#34;, 5); Iterator&amp;lt;Map.Entry&amp;lt;String, Interger&amp;gt;&amp;gt; itr = map.entrySet().iterator(); while(itr.hasNext()) { Map.Entry&amp;lt;String, Interger&amp;gt; entry = itr.next(); System.out.println(&amp;#34;Key = &amp;#34; + entry.getKey() + &amp;#34;, Value = &amp;#34; + entry.</description></item><item><title>Java String Method</title><link>https://seoah-lab.github.io/docs/java/basic/java_string_method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/basic/java_string_method/</guid><description>Java String Method # String.charAt(int index)
지정된 인덱스의 char 값을 반환합니다. String.indexOf(String str)
String.indexOf(int ch)
문자열 내에서 지정된 부분 문자열이 처음 나타나는 인덱스를 반환합니다. String.lastIndexOf​(String str)
String.lastIndexOf​(int ch)
문자열 내에서 지정된 문자의 마지막 발생 인덱스를 반환합니다. String.length()
문자열의 길이를 반환합니다. String.contains()
String.toCharArray()
String.replace()
String.replaceAll​(String regex, String replacement)
주어진 정규식과 일치하는이 문자열의 각 하위 문자열을 주어진 대체로 바꿉니다. String.toLowCase()
String.toUpperCase()
String.substring​(int beginIndex)
String.substring​(int beginIndex, int endIndex)
문자열의 인덱스의 문자를 반환 합니다.</description></item><item><title>Part 1. 기초</title><link>https://seoah-lab.github.io/docs/java/mordern_java_in_action/part1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/mordern_java_in_action/part1/</guid><description>1 장 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가? # 스트림 API
스트림이란? 한번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임
스트림의 특징
스레드를 직접 구현하지 않으면서도 멀티스레딩 shared mutable data 에 접근하지 않고 안전한 코드 실행 반복적인 코드 블록으로 인한 외부 반복에서 내부 반복으로 전환함 메서드에 코드르 전달하는 기법
동작의 파라미터화 (메서드를 전달함)
메서드를 일급으로 함수를 일급으로
메서드참조 (method reference)
람다: 익명함수
인터페이스의 디폴트 메소드</description></item><item><title>Primitive type, Reference type</title><link>https://seoah-lab.github.io/docs/java/basic/javatype/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/basic/javatype/</guid><description>Primitive type, Reference type # 1. 기본형 (Primitive) # Primitive type은 논리형, 문자형, 정수형, 실수형으로 구분된다. blooean, byte, short, int, long , float, duble, char 8가지 이다. null 이 존재하지 않는다. waper class 가 존재한다. Stack 메모리에 저장된다. 컴파일 시점에 메모리의 크기를 초과하면 에러가 발생한다. (stack over flow) 2. 참조형 (Reference type) # 기본형 타입을 제외한 타입들이 모두 참조형 타입(Reference type)이다. java.lang.Object 상속 null 이 존재하며 어떤 객체 주소도 저장되어 있지 않음을 의미한다.</description></item><item><title>Scale-up, Scale-out</title><link>https://seoah-lab.github.io/docs/infra/scale_up_scale_out/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/infra/scale_up_scale_out/</guid><description>Scale-up, Scale-out # 스케일업(Scale-up)은 단순히 말하자면 기존의 하드웨어를 보다 높은 사양으로 업그레이드하는 것을 말합니다.
스케일아웃(Scale-out)은 장비를 추가해서 확장하는 방식을 말합니다.
시스템 리소스를 확장하는 방법으로는 수평적으로 부하를 분산하는 스케일 아웃(scale out) 방식으로 확장을 할 지 아니면 해당 서버의 용량 자체를 올리는 스케일 업 (scale up) 방식으로 확장을 할지 선택해야 한다.</description></item><item><title>Part2. 함수형 데이터 처리</title><link>https://seoah-lab.github.io/docs/java/mordern_java_in_action/part2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/mordern_java_in_action/part2/</guid><description>Part2. 함수형 데이터 처리 # 4장 스트림 소개 # 스트림이란 무엇인가 Stream 자바 8 API 새로 추가된 기능이다.
자바 7의 코드
List&amp;lt;Dish&amp;gt; lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;(); for(Dish dish: menu) { if(dish.getCalories() &amp;lt; 400) { lowCaloricDishes.add(dish); } } Collections.sort(lowCaloricdishes, new Comparator&amp;lt;Dish&amp;gt;() { // 익명 클래스로 요리 정렬 pulbic int compare(Dish dish1, Dish dish2) { return Integer.compare(dish1.getCalories(), dish2.getCalories()); } }); List&amp;lt;String&amp;gt; lowCaloricDishesName = new ArrayList(); for(DIsh dish: lowCaloricDishes) { lowCaloricDishesName.add(dish.getName()); } 자바 8 후의 코드</description></item><item><title>Part3. 스트림과람다</title><link>https://seoah-lab.github.io/docs/java/mordern_java_in_action/part3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/mordern_java_in_action/part3/</guid><description>Part3. 스트림과 람다를 이용한 효과적인 프로그래밍 # 8장 컬렉션 API 개선 # 컬렉션 팩토리
적은 요소를 가지고 있는 리스트를 생성
List&amp;lt;String&amp;gt; friends = Arrays.asList(&amp;#34;Rapheal&amp;#34;, &amp;#34;Olivia&amp;#34;); UnsupportedOperationException 내부적으로 고정된 크기의 변환할 수 있는 배열로 구현 되었기 때문에 발생한다.
집합을 생성
Set&amp;lt;String&amp;gt; friends = new HashSet&amp;lt;&amp;gt;(Arrays.asList(&amp;#34;Rapheael&amp;#34;, &amp;#34;Olivia&amp;#34;, &amp;#34;Thibaut&amp;#34;)); 스트림 API 로 집합을 생성
Set&amp;lt;String&amp;gt; friends = Stream.of(&amp;#34;Raphael&amp;#34;, &amp;#34;Olivia&amp;#34;, &amp;#34;THibat&amp;#34;).collect(Collectors.toSet()); 리스트 팩토리
List.of() 로 간단한 리스트 생성
ListM&amp;lt;String&amp;gt; friend = List.of(&amp;#34;Raphael&amp;#34;, &amp;#34;Olivia&amp;#34;, &amp;#34;Thibat&amp;#34;); List.</description></item><item><title>Part5. 개선된 자바 동시성</title><link>https://seoah-lab.github.io/docs/java/mordern_java_in_action/part5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/mordern_java_in_action/part5/</guid><description>개선된 자바 동시성 # 15장 CompletableFuture와 리액티브 프로그래밍 컨셉의 기초 # 동시성을 구현하는 자바의 지원의 진화
Process : 운영체제에서 연속적으로 실행되고 있는 컴퓨터 프로그램 (한 개 이상의 스레드를 갖는다.) Thread : 프로세스 내에서 실행되는 여러 흐름의 단위
스레드를 효율적으로 사용하는 것은 컴퓨팅의 효율를 향상 시킨다.
자바에서는 스트림을 이용해 스레드 사용 패턴을 추상화 하여 병렬 스레드 활용의 효율을 증대하였다.
자바의 스레드는 직접 운영체제 스레드에 접근한다. 운영체제의 스레드를 만들고 종료하려면 페이지 테이블과 과련한 상호작용을 하면서 비싼 비용을 치러야 한다.</description></item><item><title>Part5. 함수형 프로그래밍과 자바 진화의 미래</title><link>https://seoah-lab.github.io/docs/java/mordern_java_in_action/part6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/mordern_java_in_action/part6/</guid><description>함수형 프로그래밍과 자바 진화의 미래 # 18장 함수형 관점으로 생각하기 # 18.1 시스템 구현과 유지보수
18.1.1 공유된 가변 데이터
여러 클래스에서 공유하는 가변 데이터는 어느 클래스가 소유자인지 구분하기 어렵다. 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 Side-Effect Free 메서드라고 한다. 불변 객체를 통해서 부작용을 없앴 수 있다. 18.1.2 선언형 프로그래밍
어떻게에 집중하는 방식은 명령형 프로그래밍으로 고전적인 객체지향 프로그래밍이에서 이용하는 방식 무엇을에 집중하는 방식은 선언형 프로그래밍으로 구현 방법은 질의문을 내부 반복으로 수행한다.</description></item><item><title/><link>https://seoah-lab.github.io/docs/database/mysql/mysql_index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/database/mysql/mysql_index/</guid><description>MySQL 인덱스 # 인덱스(영어: index)는 데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조를 일컫는다. Multi Coulumn Index 는 인덱스 컬럼을 연결(concat)하여 정렬한 배열입니다.
CREATE TABLE test ( id INT NOT NULL, last_name CHAR(30) NOT NULL, first_name CHAR(30) NOT NULL, PRIMARY KEY (id), INDEX name (last_name,first_name) ); 다음과 같이 멀티 컬럼 인덱스를 생성합니다. last_name을 접두사로 활용하여 검색합니다.
SELECT * FROM test WHERE last_name=&amp;#39;Jones&amp;#39;; SELECT * FROM test WHERE last_name=&amp;#39;Jones&amp;#39; AND first_name=&amp;#39;John&amp;#39;; SELECT * FROM test WHERE last_name=&amp;#39;Jones&amp;#39; AND (first_name=&amp;#39;John&amp;#39; OR first_name=&amp;#39;Jon&amp;#39;); SELECT * FROM test WHERE last_name=&amp;#39;Jones&amp;#39; AND first_name &amp;gt;=&amp;#39;M&amp;#39; AND first_name &amp;lt; &amp;#39;N&amp;#39;; 위와 같이 접두사로 활용된 last_name 이 포함되여야 멀티 컬럼 인덱스가 사용되여 조회됩니다.</description></item><item><title/><link>https://seoah-lab.github.io/docs/database/mysql/mysql_trainsaction_level/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/database/mysql/mysql_trainsaction_level/</guid><description>MySQL Transaction Isolation Levels # MySQL의 Transaction Isolation Levels READ UNCOMMITTED
다른 트랜젝션에서 COMMIT 되지 않은 데이터를 읽어올 수 있는 Level Rollback 전의 데이터를 읽어 온다면 없는 데이터를 읽게 됨 Dirty Read 신뢰할 수 없는 데이터를 읽어오는 것 아직 COMMIT 되지 않은 신뢰할 수 없는 데이터를 읽어옴(dirty read) 한 트랜잭션에서 동일한 SELECT 쿼리의 결과가 다름(non-repeatable read) 이전의 SELECT 쿼리의 결과에 없던 row가 생김(phantom read) READ COMMITTED
다른 트랜잭션에서 COMMIT 된 데이터만 읽어올 수 있는 level 한 트랜잭션에서 동일한 SELECT 쿼리의 결과가 다름(non-repeatable read) 이전의 SELECT 쿼리의 결과에 없던 row가 생김(phantom read) REPEATABLE READ</description></item><item><title/><link>https://seoah-lab.github.io/docs/java/basic/java_convert_interger_list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/basic/java_convert_interger_list/</guid><description>Convert Integer List to Int Array in Java # List 의 toArray() 메서드는 Object 타입을 지원한다. 즉 int[] 배열은 지원하지 않는다.
ArrayList toArray() # public Object[] toArray() or public &amp;lt;T&amp;gt; T[] toArray(T[] a) import java.io.*; import java.util.List; import java.util.ArrayList; class Main { public static void main(String[] args) { List&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;Integer&amp;gt;(); al.add(10); al.add(20); al.add(30); al.add(40); Object[] objects = al.toArray(); // Printing array of objects for (Object obj : objects) System.</description></item><item><title/><link>https://seoah-lab.github.io/docs/java/basic/java_math/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/basic/java_math/</guid><description> Java Math # 제곱 구하기 static double pow​(double a, double b)
double pow = Math.pow(2,2); 큰 수, 작은 수 static int min(int a , int b)
static double min(double a , double b)
static float min(float a , float b)
static long min(long a , long b)
int max = Math.max(2,3); int min = Math.min(2,3);</description></item><item><title/><link>https://seoah-lab.github.io/docs/spring/life_cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/spring/life_cycle/</guid><description>Spring Bean Lifecycle # Lifecycle을 이용해서
Spring 은 IoC 를 통하여 Bean을 관리하는 프레임 워크이다.
Bean 컨테이너(ApplicationContext)의 핵심 기능은 애플리케이션에 필요한 Bean(DI 작업이 완료되어 실행 가능한 상태의 Bean)을 생성하고, 초기화하는 것이다.
ApplicationContext는 Bean 생성 및 관리에 대한 책임을 BeanFactory에게 모두 위임한다. 즉, Spring Framework에서 Bean Lifecycle 관리에 대한 모든 책임은 BeanFactory가 가진다.
Bean의 라이프 사이클은 다음과 같은 단계로 진행된다. 생성(Create) 초기화(Init) 사용(Service) 소멸(Destory)
Bean 생성 Bean의 생성은 IoC Container를 통해 진행(싱글톤 방식) 싱글톤 방식 -&amp;gt; 인스턴스가 없다 : 생성 / 있다 : 사용 방식으로 처리</description></item><item><title>Java Character Converter</title><link>https://seoah-lab.github.io/docs/java/basic/java_charter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/basic/java_charter/</guid><description> Java Character Converter # char to int # char c = &amp;#39;1&amp;#39;; int num = Character.getNumbericValue(c); int to char # int a = 65; char c = (char)a; char to String # char c = &amp;#34;C&amp;#34;; String s = String.ValueOf(c); String to char # String s = &amp;#34;hello&amp;#34;; char c = s.charAt(0); //returns h</description></item><item><title>Java Map Sort by key and value</title><link>https://seoah-lab.github.io/docs/java/basic/java_map_sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/basic/java_map_sort/</guid><description>Java Map Sort by key and value # Map to List 를 활용 # import java.util.ArrayList; import java.util.Comparator; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.stream.Collectors; String[] array = new String[]{&amp;#34;sun&amp;#34;, &amp;#34;bed&amp;#34;, &amp;#34;car&amp;#34;}; Map&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); map.put(2, array[2]); map.put(0, array[0]); map.put(1, array[1]); // key sort List&amp;lt;Integer&amp;gt; keyList = new ArrayList&amp;lt;&amp;gt;(map.keySet()); keyList.sort(Comparator.naturalOrder()); // 오름 차순 for (Integer key : keyList) { System.out.println(&amp;#34;Key: &amp;#34; + key); } keyList.</description></item><item><title>javax @Valid</title><link>https://seoah-lab.github.io/docs/java/basic/javax_valid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://seoah-lab.github.io/docs/java/basic/javax_valid/</guid><description>javax @Valid # implementation &amp;#39;org.springframework.boot:spring-boot-starter-validation&amp;#39; @NotNull : The annotated element must not be null. Accepts any type.
null 을 허용하지않고 모든 타입에 사용할수 있다. &amp;quot;&amp;quot; 이나 &amp;quot; &amp;quot; 은 허용한다. @NotEmpty: The annotated element must not be null nor empty
null 과 &amp;quot;&amp;quot; 은 허용하지 않는다.
&amp;quot; &amp;quot; 은 허용
문자열, 콜랙션, 맵, 배열 타입에 활용할 수 있다.
CharSequence (length of character sequence is evaluated)
Collection (collection size is evaluated)</description></item></channel></rss>