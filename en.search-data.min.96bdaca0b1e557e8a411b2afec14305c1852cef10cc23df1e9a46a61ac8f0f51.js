'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/java/java_convert_interger_list/',title:"Java Convert Interger List",section:"Java",content:"Convert Integer List to Int Array in Java #  List 의 toArray() 메서드는 Object 타입을 지원한다. 즉 int[] 배열은 지원하지 않는다.\nArrayList toArray() #  public Object[] toArray() or public \u0026lt;T\u0026gt; T[] toArray(T[] a) import java.io.*; import java.util.List; import java.util.ArrayList; class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; al = new ArrayList\u0026lt;Integer\u0026gt;(); al.add(10); al.add(20); al.add(30); al.add(40); Object[] objects = al.toArray(); // Printing array of objects  for (Object obj : objects) System.out.print(obj + \u0026#34; \u0026#34;); } } Loop #  import java.util.ArrayList; public class Main { public static void main(String[] args){ List\u0026lt;Integer\u0026gt; numList = new ArrayList\u0026lt;Integer\u0026gt;(); numList.add(11); numList.add(22); numList.add(33); numList.add(44); numList.add(55); int[] numArray = int[numList.size()]; for (int i = 0; i \u0026lt; numList.size(); i++) { numArray[i] = numList.get(i); System.out.println(numArray[i]); } } } Stream().mapToInt() #  import java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args){ List\u0026lt;Integer\u0026gt; numList = new ArrayList\u0026lt;Integer\u0026gt;(); numList.add(11); numList.add(22); numList.add(33); numList.add(44); numList.add(55); int[] numArray = numList.stream().mapToInt(i-\u0026gt;i).toArray(); for (int intValue : numArray) { System.out.println(intValue); } } } "}),a.add({id:1,href:'/docs/java/java_map_iterate/',title:"Java Map to Iterate",section:"Java",content:"Java Map to Iterate #  HashMap 의 key 와 value를 확인할때 활용할 수 있는 방법은 다음과 같다.\nimport java.util.Map; import java.util.HashMap; class Iteration { public static void main(String[] arg) { Map\u0026lt;String,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // enter name/url pair 	map.put(\u0026#34;sogmy\u0026#34;, 1); map.put(\u0026#34;hyunjin\u0026#34;, 2); map.put(\u0026#34;suji\u0026#34;, 3); map.put(\u0026#34;young\u0026#34;, 4); map.put(\u0026#34;ki\u0026#34;, 5); Iterator\u0026lt;Map.Entry\u0026lt;String, Interger\u0026gt;\u0026gt; itr = map.entrySet().iterator(); while(itr.hasNext()) { Map.Entry\u0026lt;String, Interger\u0026gt; entry = itr.next(); System.out.println(\u0026#34;Key = \u0026#34; + entry.getKey() + \u0026#34;, Value = \u0026#34; + entry.getValue()); } for (Map.Entry\u0026lt;String,Interger\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;Key = \u0026#34; + entry.getKey() + \u0026#34;, Value = \u0026#34; + entry.getValue()); } for (String name : map.keySet()) { System.out.println(\u0026#34;key: \u0026#34; + name); } for (String url : map.values()) { System.out.println(\u0026#34;value: \u0026#34; + url); } map.forEach((k,v) -\u0026gt; System.out.println(\u0026#34;Key = \u0026#34; + k + \u0026#34;, Value = \u0026#34; + v)); } } "}),a.add({id:2,href:'/docs/java/mordern_java_in_action/part1/',title:"Part 1. 기초",section:"Mordern Java in Action",content:"1 장 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가? #    스트림 API\n스트림이란? 한번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임\n스트림의 특징\n 스레드를 직접 구현하지 않으면서도 멀티스레딩 shared mutable data 에 접근하지 않고 안전한 코드 실행 반복적인 코드 블록으로 인한 외부 반복에서 내부 반복으로 전환함    메서드에 코드르 전달하는 기법\n동작의 파라미터화 (메서드를 전달함)\n메서드를 일급으로 함수를 일급으로\n메서드참조 (method reference)\n람다: 익명함수\n  인터페이스의 디폴트 메소드\n인터페이스 내부에 새로운 메소드를 구현\n  함수형 프로그래밍\n  2 장 동적 파라미터화 코드전달하기 #  변화하는 요구 사항에 대응하기 (예제로 동적 파라미터화 이해하기)\n첫번째 시도 : 녹색사과 필터링\nList\u0026lt;Apple\u0026gt; inventory = Arrays.asList( new Apple(80, Color.GREEN), new Apple(155, Color.GREEN), new Apple(120, Color.RED)); public static List\u0026lt;Apple\u0026gt; filterGreenApples(List\u0026lt;Apple\u0026gt; inventory) { List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (Apple apple : inventory) { if (\u0026#34;green\u0026#34;.equals(apple.getColor())) { result.add(apple); } } return result; } public static List\u0026lt;Apple\u0026gt; filterHeavyApples(List\u0026lt;Apple\u0026gt; inventory) { List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (Apple apple : inventory) { if (apple.getWeight() \u0026gt; 150) { result.add(apple); } } return result; } 두번째 시도 : 색을 파라미터화\n Color enum으로 일급 객체화  public static List\u0026lt;Apple\u0026gt; filterApplesByColor(List\u0026lt;Apple\u0026gt; inventory, Color color) { List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (Apple apple : inventory) { if (apple.getColor() == color) { result.add(apple); } } return result; } List\u0026lt;Apple\u0026gt; greenApples = filterApplesByColor(inventory, Color.GREEN); System.out.println(greenApples); 세번째 시도: 가능한 모든 속성을 필터링\n네번째 시도: 추상적 조건으로 필터링\n//인터페이스로 추상화 interface ApplePredicate { boolean test(Apple a); } //인터페이스를 구현 static class AppleWeightPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return apple.getWeight() \u0026gt; 150; } } static class AppleColorPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return apple.getColor() == Color.GREEN; } } static class AppleRedAndHeavyPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return apple.getColor() == Color.RED\u0026amp;\u0026amp; apple.getWeight() \u0026gt; 150; } } public static List\u0026lt;Apple\u0026gt; filter(List\u0026lt;Apple\u0026gt; inventory, ApplePredicate p) { List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (Apple apple : inventory) { if (p.test(apple)) { result.add(apple); } } return result; } // [Apple{color=GREEN, weight=80}, Apple{color=GREEN, weight=155}] List\u0026lt;Apple\u0026gt; greenApples2 = filter(inventory, new AppleColorPredicate()); System.out.println(greenApples2); // [Apple{color=GREEN, weight=155}] List\u0026lt;Apple\u0026gt; heavyApples = filter(inventory, new AppleWeightPredicate()); System.out.println(heavyApples); // [] List\u0026lt;Apple\u0026gt; redAndHeavyApples = filter(inventory, new AppleRedAndHeavyPredicate()); System.out.println(redAndHeavyApples); 다섯번째 시도: 익명클래스 사용\nList\u0026lt;Apple\u0026gt; redApples = filter(inventory, new ApplePredicate() { @Override public boolean test(Apple a) { return RED.equals(apple.getColor()); } }); 여섯번째 시도 : 람다 표현식\nList\u0026lt;Apple\u0026gt; result = filterApples(inventory, (Apple apple) -\u0026gt; RED.equals(apple.getcolor())); 일곱번째 시도: 리스트 형식의 추상화\npublic static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; filter(List\u0026lt;T\u0026gt; list, Predicate\u0026lt;T\u0026gt; p ) { List\u0026lt;T\u0026gt; result = new ArrayList\u0026lt;\u0026gt;; for(T e: list) { if(p.test(e)) { result.add(e); } } return result; } 3장 람다 표현식 #    익명 : 보통 메서드와 달리 이름이 없으므로 익명이라 표현한다.\n  함수 : 특정 클래스에 종속되지 않으므로 메서드 대신 함수라고 표현한다.\n  전달 : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.\n  간결성 : 익명 클래스처럼 많은 코드를 구현할 필요가 없다.\nComparator\u0026lt;Apple\u0026gt; byWeight = new Comparator\u0026lt;Apple\u0026gt;() { public int compare(Apple a1, Apple a2) { return a1.getWeight().compareTo(a2.getWeight()); } } Compartor\u0026lt;Apple\u0026gt; byWeight = (Apple a1, Apple a2) -\u0026gt; a1.getWeight().compareTo(a2.getWeight());   함수형 인터페이스라는 문맥에서 람다 표현식을 사용할수 있다.\n함수형 인터페이스\n 함수형 인터페이스는 정확히 하나의 추상메서드를 지정하는 인터페이스이다.  함수 디스크립터\n 함수 디스크립터는 람다에서의 메소드 시그니처를 표현하는 메서드를 말한다.  람다 활용\n실행 어라운드 패턴\n자원 처리(예를 들면 DB의 파일 처리)에 사용하는 순환 패턴은 자원을 열고, 처리한 다음에, 자원을 닫는 순서로 이루어진다. 설정과 정리 과정은 대부분 비슷하다. 즉, 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 갖는데 이 같은 형식의 코드를 실행 어라운드 패턴이라고 부른다.\nprivate static final String FILE = ExecuteAround.class.getResource(\u0026#34;./data.txt\u0026#34;).getFile(); public static String processFileLimited() throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(FILE))) { return br.readLine(); } } //(1) 실행 어라운트 패턴의 구현  public static String processFile(BufferedReaderProcessor p) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(FILE))) { return p.process(br); } } public interface BufferedReaderProcessor { String process(BufferedReader b) throws IOException; } public static void main(String... args) throws IOException { // 더 유연하게 리팩토링할 메서드  String result = processFileLimited(); System.out.println(result); System.out.println(\u0026#34;---\u0026#34;); String oneLine = processFile((BufferedReader b) -\u0026gt; b.readLine()); System.out.println(oneLine); String twoLines = processFile((BufferedReader b) -\u0026gt; b.readLine() + b.readLine()); System.out.println(twoLines); } 함수형 인터페이스의 사용\n Predicate  @FunctionalInterface public interface Predicate\u0026lt;T\u0026gt; { /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ boolean test(T t); }  Consumeer  @FunctionalInterface public interface Consumer\u0026lt;T\u0026gt; { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); }  Function  @FunctionalInterface public interface Function\u0026lt;T, R\u0026gt; { /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); } 람다의 형식 검사, 형식 추론, 제약\n 형식검사  filter (inventory, (Apple apple) -\u0026gt; apple.getWeight() \u0026gt; 150) //같은 람다, 다른 함수형 인터페이스 Callable\u0026lt;Integer\u0026gt; c = () -\u0026gt; 42; PrivilegedAction\u0026lt;Integer\u0026gt; p = () -\u0026gt; 42;  형식 추론  filter (inventory, (Apple apple) -\u0026gt; apple.getWeight() \u0026gt; 150) filter (inventory, apple -\u0026gt; apple.getWeight() \u0026gt; 150) //Apple 은 생략 가능하다.  제약  람다에서 지역변수는 람다 캡처링에 의해서 final 변수와 동일하게 사용해야 한다.\nint portNumber = 1337; Runnable r = () -\u0026gt; System.out.prinln(portNumber); portNumber = 31337; //컴파일 오류 발생 메서드 참조\n메소드 참조(method reference)는 람다 표현식이 단 하나의 메소드만을 호출하는 경우에 해당 람다 표현식에서 불필요한 매개변수를 제거하고 사용할 수 있다.\ninventory.sort((a1, a2) -\u0026gt; a1.getWeight().compareTo(a2.getWeight)); inventory.sort(comparing(Apple::getWeight)); 생성자 참조\n단순히 객체를 생성하고 반환하는 람다 표현식은 생성자 참조로 변환\nSupplier\u0026lt;Apple\u0026gt; c1 = Apple::new; Supplier\u0026lt;Apple\u0026gt; c1 = () -\u0026gt; new Apple(); Apple a1 = c2.get(); Function\u0026lt;Integer, Apple\u0026gt; c2 = Apple::new; Function\u0026lt;Integer, Apple\u0026gt; c2 = (weight) -\u0026gt; new Apple(weight); Apple a2 = c2.aply(110); 람다 표현식을 조합할 수 있는 유용한 메소드\n Comparator 조합  // 비교를 이용해 Comparator를 반환 Comparator\u0026lt;Apple\u0026gt; c = Comparator.comparing(Apple::getWeight); // 역정렬 inventory.sort(comparing(Apple::getWeight).reversed()); // \u0026lt;- 무게 내림차순으로 정렬  // 연결 inventory.sort(comparing(Apple::getWeight) .reversed() // \u0026lt;- 무게 내림차순으로 정렬 	.thenComparing(Apple::getCountry)); // 두 사과의 무게가 같은면 국가 별로 정렬  Predicate 조합\n//기존 프레디케이트 객체결과를 반전시킨 결과 Predicate\u0026lt;Apple\u0026gt; notRedApple = redApple.negate(); // 두개 연결 Predicate\u0026lt;Apple\u0026gt; redAndHeavyApple = redApple.and(apple -\u0026gt; apple.getWeight() \u0026gt; 150); // 연결해서 복잡한 결과 Predicate\u0026lt;Apple\u0026gt; redAndHeavyApple = redApple.and(apple -\u0026gt; apple.getWeight() \u0026gt; 150) .or(GREEN.equals(a.getColor())); Funtion 조합\nFunction\u0026lt;Integer, Integer\u0026gt; f = x -\u0026gt; x + 1; Function\u0026lt;Integer, Integer\u0026gt; g = x -\u0026gt; x * 5; Function\u0026lt;Integer, Integer\u0026gt; h = f.andThen(g); int result = h.appy(1); //4 반환  Function\u0026lt;Integer, Integer\u0026gt; f = x -\u0026gt; x + 1; Function\u0026lt;Integer, Integer\u0026gt; g = x -\u0026gt; x * 5; Function\u0026lt;Integer, Integer\u0026gt; h = f.compose(g); int result = h.appy(1); //3 반환 "}),a.add({id:3,href:'/docs/java/javatype/',title:"Primitive type, Reference type",section:"Java",content:"Primitive type, Reference type #  1. 기본형 (Primitive) #   Primitive type은 논리형, 문자형, 정수형, 실수형으로 구분된다. blooean, byte, short, int, long , float, duble, char 8가지 이다. null 이 존재하지 않는다. waper class 가 존재한다. Stack 메모리에 저장된다. 컴파일 시점에 메모리의 크기를 초과하면 에러가 발생한다. (stack over flow)  2. 참조형 (Reference type) #   기본형 타입을 제외한 타입들이 모두 참조형 타입(Reference type)이다. java.lang.Object 상속 null 이 존재하며 어떤 객체 주소도 저장되어 있지 않음을 의미한다. 객체 주소값을 저장 heap 메모리에 저장한다.  자료형(data type) 과 타입(type) 의 차이 #  type 이 더 포괄적인 의미이다. 기본형과 다르게 참조형은 객체의 주소값을 저장하므로 data가 아닌 type 이라는 용어를 사용한다. (자바의 정석 - p.28)\n"}),a.add({id:4,href:'/docs/infra/scale_up_scale_out/',title:"Scale-up, Scale-out",section:"Infra",content:"Scale-up, Scale-out #  스케일업(Scale-up)은 단순히 말하자면 기존의 하드웨어를 보다 높은 사양으로 업그레이드하는 것을 말합니다.\n스케일아웃(Scale-out)은 장비를 추가해서 확장하는 방식을 말합니다.\n시스템 리소스를 확장하는 방법으로는 수평적으로 부하를 분산하는 스케일 아웃(scale out) 방식으로 확장을 할 지 아니면 해당 서버의 용량 자체를 올리는 스케일 업 (scale up) 방식으로 확장을 할지 선택해야 한다.\n"}),a.add({id:5,href:'/docs/java/ect/java_string_method/',title:"String Method",section:"Ect",content:"String 의 주요 메소드 정리 #  String.charAt(int index)\n 지정된 인덱스의 char 값을 반환합니다.  String.indexOf(String str)\nString.indexOf(int ch)\n 문자열 내에서 지정된 부분 문자열이 처음 나타나는 인덱스를 반환합니다.  String.lastIndexOf​(String str)\nString.lastIndexOf​(int ch)\n 문자열 내에서 지정된 문자의 마지막 발생 인덱스를 반환합니다.  String.length()\n 문자열의 길이를 반환합니다.  String.contains()\nString.toCharArray()\nString.replace()\nString.replaceAll​(String regex, String replacement)\n 주어진 정규식과 일치하는이 문자열의 각 하위 문자열을 주어진 대체로 바꿉니다.  String.toLowCase()\nString.toUpperCase()\nString.substring​(int beginIndex)\nString.substring​(int beginIndex, int endIndex)\n 문자열의 인덱스의 문자를 반환 합니다.  String.compareTo​(String anotherString)\n 두 문자열을 사전 순으로 비교합니다  "}),a.add({id:6,href:'/docs/java/mordern_java_in_action/part2/',title:"Part2. 함수형 데이터 처리",section:"Mordern Java in Action",content:"Part2. 함수형 데이터 처리 #  4장 스트림 소개 #  스트림이란 무엇인가 Stream 자바 8 API 새로 추가된 기능이다.\n자바 7의 코드\nList\u0026lt;Dish\u0026gt; lowCaloricDishes = new ArrayList\u0026lt;\u0026gt;(); for(Dish dish: menu) { if(dish.getCalories() \u0026lt; 400) { lowCaloricDishes.add(dish); } } Collections.sort(lowCaloricdishes, new Comparator\u0026lt;Dish\u0026gt;() { // 익명 클래스로 요리 정렬  pulbic int compare(Dish dish1, Dish dish2) { return Integer.compare(dish1.getCalories(), dish2.getCalories()); } }); List\u0026lt;String\u0026gt; lowCaloricDishesName = new ArrayList(); for(DIsh dish: lowCaloricDishes) { lowCaloricDishesName.add(dish.getName()); } 자바 8 후의 코드\nimport static java.util.Comparator.comparing; import static java.util.stream.Collectors.toList; List\u0026lt;String\u0026gt; lowCaloricDishesName = menu.stream() //parallelStream 을 사용하면 병렬  .filter(d -\u0026gt; d.getCalories() \u0026lt; 400\u0026gt;) //400 칼로리 미만의 요리 선택  .sorted(comparing(Dishes::getCalories)) // 칼로리로 정렬  .map(Dish::getName) // 요리명 추출  .collect(toList()); // 모든 요리명 리스트에 저장  자바 8 스트림 API 의 특징\n 선언형 : 더 간결하고 가독성이 좋아진다. 조립할 수 있음 : 유연성이 좋아진다. 병렬성 : 성능이 좋아진다.  스트림 시작하기\n데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소 (Squence of element)로 정의할 수 있다.\n 연속 된 요소 소스 데이터 처리 연산  스트림의 주요 특징\n 파이프라이닝 : Laziness, short-circuiting 내부반복  스트림의 주요 기능\n filter : 람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다. map : 람다를 이용해서 한 요소를 다른 요소로 변환하거나 정보를 추출한다. limit: 스트림 크기를 제한한다. collect: 스트림을 다른 형식으로 변환한다.  스트림의 연산\n 중간연산 - 쇼트 서킷, 서로 다른 연산이지만 병합되는 기법 루프 퓨전(loop fusioin) 최종연산  5장 스트림 활용 #  Optional?\nOptional 값의 존재나 부재 여부를 표현하는 컨테이너 클래스\nnull 은 쉽게 에러를 일으킬 수 있으므로 자바 8 라이브러리 설계자는 Optional를 만들었다.\n isPresent(): 값이 있으면 참을 반환한다. T get() : 값이 존재하면 값을 반환하고 없으면 NoSuchElementException을 일으킨다. T orElse(T other): 값이 있으면 값을 반환하고, 값이 없으면 기본값을 반환한다.  findFirst와 findAny 는 언제 사용하나?\n병렬 스트림에서는 첫 번째 요소를 찾기 어렵다. 요소의 순서가 상관없다면 findAny를 사용한다.\n리듀싱 모든 스트림 요소를 반복 처리해서 값으로 도출하는 리듀싱 연산을 한다. 함수형 프로그래밍 언어 용어로는 폴드라고 부른다.\nint sum = 0; for (int x : number) { sum += x; } //초기 값 0 int sum = numbers.stream().reduce(0, ( a,b,) -\u0026gt; a + b); //초기 값 없이 사용 Optional\u0026lt;Integer\u0026gt; sum = numbers.stream().reduce((a,b) -\u0026gt; (a + b)); //최대값 최솟값 Optional\u0026lt;Integer\u0026gt; max = numbers.stream().reduce(Integer::max); Optional\u0026lt;Integer\u0026gt; min = numbers.stream().reduce(Integer::min); 6장 스트림으로 데이터 수집 #  7장 병렬 데이터 처리와 성능 #  "}),a.add({id:7,href:'/docs/java/mordern_java_in_action/part3/',title:"Part3. 스트림과람다",section:"Mordern Java in Action",content:"Part3. 스트림과 람다를 이용한 효과적인 프로그래밍 #  8장 컬렉션 API 개선 #  컬렉션 팩토리\n적은 요소를 가지고 있는 리스트를 생성\nList\u0026lt;String\u0026gt; friends = Arrays.asList(\u0026#34;Rapheal\u0026#34;, \u0026#34;Olivia\u0026#34;); UnsupportedOperationException 내부적으로 고정된 크기의 변환할 수 있는 배열로 구현 되었기 때문에 발생한다.\n집합을 생성\nSet\u0026lt;String\u0026gt; friends = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;Rapheael\u0026#34;, \u0026#34;Olivia\u0026#34;, \u0026#34;Thibaut\u0026#34;)); 스트림 API 로 집합을 생성\nSet\u0026lt;String\u0026gt; friends = Stream.of(\u0026#34;Raphael\u0026#34;, \u0026#34;Olivia\u0026#34;, \u0026#34;THibat\u0026#34;).collect(Collectors.toSet()); 리스트 팩토리\nList.of() 로 간단한 리스트 생성\nListM\u0026lt;String\u0026gt; friend = List.of(\u0026#34;Raphael\u0026#34;, \u0026#34;Olivia\u0026#34;, \u0026#34;Thibat\u0026#34;); List.of() 로 생성한 리스트에 요소를 추가하거나 변경하려고 하면 UnsupportedOperationException 이 발생한다.\n스트림으로도 리스트를 생성할 수 있다. 데이터 처리 형식을 설정하거나 데이터를 변환할 필요가 없다면 사용하기 편한 팩토리 메서드를 이용할 것을 권장한다.\n집합 팩토리\n집합 팩토리로 집합으로 생성\nSet\u0026lt;String\u0026gt; friends = Set.of(\u0026#34;Raphael\u0026#34;, \u0026#34;Olivia\u0026#34;, \u0026#34;Thibat\u0026#34;); 맵 팩토리\n맵팩토리를 활용하여 생성\nimport java.util.Mpa.entry; Map\u0026lt;String, Integer\u0026gt; ageOfFriends = Mpa.ofEntries(entry(\u0026#34;Raphael\u0026#34;, 30), entry(\u0026#34;Oliva\u0026#34;, 25), entry(\u0026#34;Thibat\u0026#34;, 30)); 리스트와 집합의 처리\n"}),a.add({id:8,href:'/docs/java/mordern_java_in_action/part5/',title:"Part5. 개선된 자바 동시성",section:"Mordern Java in Action",content:"개선된 자바 동시성 #  15장 CompletableFuture와 리액티브 프로그래밍 컨셉의 기초 #  동시성을 구현하는 자바의 지원의 진화\nProcess : 운영체제에서 연속적으로 실행되고 있는 컴퓨터 프로그램 (한 개 이상의 스레드를 갖는다.) Thread : 프로세스 내에서 실행되는 여러 흐름의 단위\n스레드를 효율적으로 사용하는 것은 컴퓨팅의 효율를 향상 시킨다.\n자바에서는 스트림을 이용해 스레드 사용 패턴을 추상화 하여 병렬 스레드 활용의 효율을 증대하였다.\n자바의 스레드는 직접 운영체제 스레드에 접근한다. 운영체제의 스레드를 만들고 종료하려면 페이지 테이블과 과련한 상호작용을 하면서 비싼 비용을 치러야 한다. 운영체제의 스레드의 숫자는 제한 되어 있어 스레드 수가 초과되면 크래시될 수 있다.\nThread Pool : 스레드 풀은 스레드 그룹을 관리한다.\n 자원 낭비 감소 : 기존 스레드를 재사용하여 스레드를 다시 만드는 오버 헤드를 줄일 수 있습니다. 스레드의 중앙 집중식 관리. 스레드 풀은 다양한 매개 변수를 표시하여 스레드를 모니터링하고 최적화하는 데 도움이되는 기능을 제공합니다.  "}),a.add({id:9,href:'/docs/java/mordern_java_in_action/part6/',title:"Part5. 함수형 프로그래밍과 자바 진화의 미래",section:"Mordern Java in Action",content:"함수형 프로그래밍과 자바 진화의 미래 #  18장 함수형 광점으로 생각하기 #  18.1 시스템 구현과 유지보수\n18.1.1 공유된 가변 데이터\n- 여러 클래스에서 공유하는 가변 데이터는 어느 클래스가 소유자인지 구분하기 어렵다. - 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 Side-Effect Free 메서드라고 한다. - 불변 객체를 통해서 부작용을 없앴 수 있다. 18.1.2 선언형 프로그래밍\n- 어떻게에 집중하는 방식은 명령형 프로그래밍으로 고전적인 객체지향 프로그래밍이에서 이용하는 방식 - 무엇을에 집중하는 방식은 선언형 프로그래밍으로 구현 방법은 질의문을 내부 반복으로 수행한다. - 선언형 프로그래밍은 질의문 자체로 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다. 18.1.3 왜 함수형 프로그래밍인가?\n- 함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며 부작용이 없는 계산을 지향한다. 18.2 함수형 프로그래밍이란 무엇인가?\n 함수를 이용하는 프로그래밍으로 함수의 의미는 수학적인 함수와 같다. 0개 이상의 인수를 가지며 한개 이상의 결과를 반환하지만 부작용(side-effect)이 없어야 한다.\n  시스템의 다른 부분의 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능을 사용하는 방식을 함수형 프로그래밍이라 한다.\n 18.2.1 함수형 자바\n실질적으로 자바는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 1. 함수나 메서드는 지역 변수만을 변경해야 함수형이라고 할 수 있다. 2. 모든 객체는 불변 객체여야 한다. 3. 함수나 메서드가 어떤 예외도 일으키지 않아야 한다. 4. 수학정 함수는 주어진 인수에 하나의 값을 반환한다. 5. 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야한다. 18.2.2 참조 투명성\n- `부작용은 감춰야한다` 라는 제약은 참조 투명성 (referential transparency) 개념으로 귀결된다. - 같은 인수이면 같은 결과값을 반환해야 한다. - List 같은 경우 같은 두번의 호출로 같은 요소를 포함하지만 메모리 공간은 다른 곳에 생성된다. 불변의 순수 값을 사용할 것이라면 참조적으로 투명한 것으로 간주 한다. 18.2.3 객체지향 프로그래밍과 함수형 프로그래밍\n자바는 익스트림 객체지향 방식과 함수형 방식을 모두 취한다. 18.3 재귀와 반복\n 순수 함수형 프로그래밍 언어에서는 while, for 같은 반복문을 사용하지 않는다.\n 팩토리얼 예제\nstatic int factorialIterative(int n) { int r = 1; for (int i = 1; i \u0026lt;= n; i++) { r *= i; } return r; } static long factorialRecusive(long n) { return n == 1 ? 1 : n * factorialRecusive(n-1); } static long factorialSteames(long n) { return LongSteream.rangeClosed(1, n) .reduce(1,(long a, long b) -\u0026gt; a * b); } 꼬리 재귀 팩토리얼\nstatic long factorialTailRecusive(long n) { return factorialHelper(1,n); } static long fcatorialHelper(long acc, long n) { return n == 1 ? acc : factorialHelper(acc * n , n -1); } 중간 값을 각자의 스택 프레임으로 저장해야하는 일반 재귀와 달리 꼬리 재귀는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 있으나 자바에서는 지원하지 않는다.(스칼라 그루비 같은 jvm 언어는 이와 같은 재귀 반복을 최적화 한다.)\n  공유 가변 자료구조를 줄이는 것은 장기적으로 프로그램 유지보수하고 디버깅하는 데 도움이 된다. 함수형 프로그래밍은 부작용이 없는 메서드와 선언형 프로그래밍 방식을 지향한다. 함수형 메서드는 입력 인수와 출력 결과만을 갖는다. 같은 인수 값으로 함수를 호출했을 때 항상 같은 값을 반환하면 참조 투명성을 갖는 함수다. while 루프 같은 반복움능 재귀로 대체할 수 있다. 자바에서는 고전 방식의 재귀보다 꼬리 재귀를 사용해야 추가적인 컴파일러 최적화를 기대할 수 있다.   19 함수형 프로그래밍 기법 #  19.1 함수는 모든 곳에 존재한다. 19.1.1 고차원 함수\nComparator.comparing 정적메소드과 같이 다음과 같은 기능을 하나이상하는 함수를 고차원함수라고 한다. - 하나 이상의 함수를 인수로 받음 - 함수를 결과로 반환 함수를 인수로 전달결과 반환 지역변수로 할당 구조체로 삽입할 수 있으므로 자바의 함수도 고차원 함수라고 할수 있다. 고차원 함수를 사용할 때 함수에서 어떤 언지가 사용되고 예상 못한 결과가 발생할 수 있다. 고차원 함수 구현시 사이드 이팩트를 고려해야 한다.\n19.1.2 커링 (Currying)\nCurrying은 여러 개의 인자를 가진 함수를 호출 할 경우, 파라미터의 수보다 적은 수의 파라미터를 인자로 받으면 누락된 파라미터를 인자로 받는 기법을 말한다. 부분적으로 적용된 함수를 체인으로 계속 생성해 결과적으로 값을 처리하도록 하는 것이 그 본질이다. 19.2 영속 자료구조 19.2.1 파과적인 갱신과 함수형\n"}),a.add({id:10,href:'/docs/java/ect/javax_valid/',title:"javax @Valid",section:"Ect",content:"javax @Valid #  implementation 'org.springframework.boot:spring-boot-starter-validation' @NotNull : The annotated element must not be null. Accepts any type.\n null 을 허용하지않고 모든 타입에 사용할수 있다. \u0026quot;\u0026quot; 이나 \u0026quot; \u0026quot; 은 허용한다.  @NotEmpty: The annotated element must not be null nor empty\n  null 과 \u0026quot;\u0026quot; 은 허용하지 않는다.\n  \u0026quot; \u0026quot; 은 허용\n  문자열, 콜랙션, 맵, 배열 타입에 활용할 수 있다.\n  CharSequence (length of character sequence is evaluated)\n  Collection (collection size is evaluated)\n  Map (map size is evaluated)\n  Array (array length is evaluated)\n  @NotBlank : The annotated element must not be null and must contain at least one non-whitespace character. Accepts\n null 과 \u0026quot;\u0026quot; 과 \u0026quot; \u0026quot; 모두 허용하지 않는다.  @Null : The annotated element must be null\n null을 허용한다.  출처\nJava EE \n"})})()