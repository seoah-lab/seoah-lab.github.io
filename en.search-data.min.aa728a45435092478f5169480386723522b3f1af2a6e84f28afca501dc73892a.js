'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/java/convert_interger_list/',title:"Convert Interger List",section:"Java",content:"Convert Integer List to Int Array in Java #  List 의 toArray() 메서드는 Object 타입을 지원한다. 즉 int[] 배열은 지원하지 않는다.\nArrayList toArray() #  public Object[] toArray() or public \u0026lt;T\u0026gt; T[] toArray(T[] a) import java.io.*; import java.util.List; import java.util.ArrayList; class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; al = new ArrayList\u0026lt;Integer\u0026gt;(); al.add(10); al.add(20); al.add(30); al.add(40); Object[] objects = al.toArray(); // Printing array of objects  for (Object obj : objects) System.out.print(obj + \u0026#34; \u0026#34;); } } Loop #  import java.util.ArrayList; public class Main { public static void main(String[] args){ List\u0026lt;Integer\u0026gt; numList = new ArrayList\u0026lt;Integer\u0026gt;(); numList.add(11); numList.add(22); numList.add(33); numList.add(44); numList.add(55); int[] numArray = int[numList.size()]; for (int i = 0; i \u0026lt; numList.size(); i++) { numArray[i] = numList.get(i); System.out.println(numArray[i]); } } } Stream().mapToInt() #  import java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args){ List\u0026lt;Integer\u0026gt; numList = new ArrayList\u0026lt;Integer\u0026gt;(); numList.add(11); numList.add(22); numList.add(33); numList.add(44); numList.add(55); int[] numArray = numList.stream().mapToInt(i-\u0026gt;i).toArray(); for (int intValue : numArray) { System.out.println(intValue); } } } "}),a.add({id:1,href:'/docs/java/map_iterate/',title:"Map to Iterate",section:"Java",content:"Map to Iterate #  HashMap 의 key 와 value를 확인할때 활용할 수 있는 방법은 다음과 같다.\nimport java.util.Map; import java.util.HashMap; class Iteration { public static void main(String[] arg) { Map\u0026lt;String,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // enter name/url pair 	map.put(\u0026#34;sogmy\u0026#34;, 1); map.put(\u0026#34;hyunjin\u0026#34;, 2); map.put(\u0026#34;suji\u0026#34;, 3); map.put(\u0026#34;young\u0026#34;, 4); map.put(\u0026#34;ki\u0026#34;, 5); Iterator\u0026lt;Map.Entry\u0026lt;String, Interger\u0026gt;\u0026gt; itr = map.entrySet().iterator(); while(itr.hasNext()) { Map.Entry\u0026lt;String, Interger\u0026gt; entry = itr.next(); System.out.println(\u0026#34;Key = \u0026#34; + entry.getKey() + \u0026#34;, Value = \u0026#34; + entry.getValue()); } for (Map.Entry\u0026lt;String,Interger\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;Key = \u0026#34; + entry.getKey() + \u0026#34;, Value = \u0026#34; + entry.getValue()); } for (String name : map.keySet()) { System.out.println(\u0026#34;key: \u0026#34; + name); } for (String url : map.values()) { System.out.println(\u0026#34;value: \u0026#34; + url); } map.forEach((k,v) -\u0026gt; System.out.println(\u0026#34;Key = \u0026#34; + k + \u0026#34;, Value = \u0026#34; + v)); } } "}),a.add({id:2,href:'/docs/java/mordern_java_in_action/part1/',title:"Part 1. 기초",section:"Mordern Java in Action",content:"1 장 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가? #    스트림 API\n스트림이란? 한번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임\n스트림의 특징\n 스레드를 직접 구현하지 않으면서도 멀티스레딩 shared mutable data 에 접근하지 않고 안전한 코드 실행 반복적인 코드 블록으로 인한 외부 반복에서 내부 반복으로 전환함    메서드에 코드르 전달하는 기법\n동작의 파라미터화 (메서드를 전달함)\n메서드를 일급으로 함수를 일급으로\n메서드참조 (method reference)\n람다: 익명함수\n  인터페이스의 디폴트 메소드\n인터페이스 내부에 새로운 메소드를 구현\n  함수형 프로그래밍\n  2 장 동적 파라미터화 코드전달하기 #  변화하는 요구 사항에 대응하기 (예제로 동적 파라미터화 이해하기)\n첫번째 시도 : 녹색사과 필터링\nList\u0026lt;Apple\u0026gt; inventory = Arrays.asList( new Apple(80, Color.GREEN), new Apple(155, Color.GREEN), new Apple(120, Color.RED)); public static List\u0026lt;Apple\u0026gt; filterGreenApples(List\u0026lt;Apple\u0026gt; inventory) { List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (Apple apple : inventory) { if (\u0026#34;green\u0026#34;.equals(apple.getColor())) { result.add(apple); } } return result; } public static List\u0026lt;Apple\u0026gt; filterHeavyApples(List\u0026lt;Apple\u0026gt; inventory) { List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (Apple apple : inventory) { if (apple.getWeight() \u0026gt; 150) { result.add(apple); } } return result; } 두번째 시도 : 색을 파라미터화\n Color enum으로 일급 객체화  public static List\u0026lt;Apple\u0026gt; filterApplesByColor(List\u0026lt;Apple\u0026gt; inventory, Color color) { List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (Apple apple : inventory) { if (apple.getColor() == color) { result.add(apple); } } return result; } List\u0026lt;Apple\u0026gt; greenApples = filterApplesByColor(inventory, Color.GREEN); System.out.println(greenApples); 세번째 시도: 가능한 모든 속성을 필터링\n네번째 시도: 추상적 조건으로 필터링\n//인터페이스로 추상화 interface ApplePredicate { boolean test(Apple a); } //인터페이스를 구현 static class AppleWeightPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return apple.getWeight() \u0026gt; 150; } } static class AppleColorPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return apple.getColor() == Color.GREEN; } } static class AppleRedAndHeavyPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return apple.getColor() == Color.RED\u0026amp;\u0026amp; apple.getWeight() \u0026gt; 150; } } public static List\u0026lt;Apple\u0026gt; filter(List\u0026lt;Apple\u0026gt; inventory, ApplePredicate p) { List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (Apple apple : inventory) { if (p.test(apple)) { result.add(apple); } } return result; } // [Apple{color=GREEN, weight=80}, Apple{color=GREEN, weight=155}] List\u0026lt;Apple\u0026gt; greenApples2 = filter(inventory, new AppleColorPredicate()); System.out.println(greenApples2); // [Apple{color=GREEN, weight=155}] List\u0026lt;Apple\u0026gt; heavyApples = filter(inventory, new AppleWeightPredicate()); System.out.println(heavyApples); // [] List\u0026lt;Apple\u0026gt; redAndHeavyApples = filter(inventory, new AppleRedAndHeavyPredicate()); System.out.println(redAndHeavyApples); 다섯번째 시도: 익명클래스 사용\nList\u0026lt;Apple\u0026gt; redApples = filter(inventory, new ApplePredicate() { @Override public boolean test(Apple a) { return RED.equals(apple.getColor()); } }); 여섯번째 시도 : 람다 표현식\nList\u0026lt;Apple\u0026gt; result = filterApples(inventory, (Apple apple) -\u0026gt; RED.equals(apple.getcolor())); 일곱번째 시도: 리스트 형식의 추상화\npublic static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; filter(List\u0026lt;T\u0026gt; list, Predicate\u0026lt;T\u0026gt; p ) { List\u0026lt;T\u0026gt; result = new ArrayList\u0026lt;\u0026gt;; for(T e: list) { if(p.test(e)) { result.add(e); } } return result; } 3장 람다 표현식 #    익명 : 보통 메서드와 달리 이름이 없으므로 익명이라 표현한다.\n  함수 : 특정 클래스에 종속되지 않으므로 메서드 대신 함수라고 표현한다.\n  전달 : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.\n  간결성 : 익명 클래스처럼 많은 코드를 구현할 필요가 없다.\nComparator\u0026lt;Apple\u0026gt; byWeight = new Comparator\u0026lt;Apple\u0026gt;() { public int compare(Apple a1, Apple a2) { return a1.getWeight().compareTo(a2.getWeight()); } } Compartor\u0026lt;Apple\u0026gt; byWeight = (Apple a1, Apple a2) -\u0026gt; a1.getWeight().compareTo(a2.getWeight());   함수형 인터페이스라는 문맥에서 람다 표현식을 사용할수 있다.\n함수형 인터페이스\n 함수형 인터페이스는 정확히 하나의 추상메서드를 지정하는 인터페이스이다.  함수 디스크립터\n 함수 디스크립터는 람다에서의 메소드 시그니처를 표현하는 메서드를 말한다.  람다 활용\n실행 어라운드 패턴\n자원 처리(예를 들면 DB의 파일 처리)에 사용하는 순환 패턴은 자원을 열고, 처리한 다음에, 자원을 닫는 순서로 이루어진다. 설정과 정리 과정은 대부분 비슷하다. 즉, 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 갖는데 이 같은 형식의 코드를 실행 어라운드 패턴이라고 부른다.\nprivate static final String FILE = ExecuteAround.class.getResource(\u0026#34;./data.txt\u0026#34;).getFile(); public static String processFileLimited() throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(FILE))) { return br.readLine(); } } //(1) 실행 어라운트 패턴의 구현  public static String processFile(BufferedReaderProcessor p) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(FILE))) { return p.process(br); } } public interface BufferedReaderProcessor { String process(BufferedReader b) throws IOException; } public static void main(String... args) throws IOException { // 더 유연하게 리팩토링할 메서드  String result = processFileLimited(); System.out.println(result); System.out.println(\u0026#34;---\u0026#34;); String oneLine = processFile((BufferedReader b) -\u0026gt; b.readLine()); System.out.println(oneLine); String twoLines = processFile((BufferedReader b) -\u0026gt; b.readLine() + b.readLine()); System.out.println(twoLines); } 함수형 인터페이스의 사용\n Predicate  @FunctionalInterface public interface Predicate\u0026lt;T\u0026gt; { /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ boolean test(T t); }  Consumeer  @FunctionalInterface public interface Consumer\u0026lt;T\u0026gt; { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); }  Function  @FunctionalInterface public interface Function\u0026lt;T, R\u0026gt; { /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); } 람다의 형식 검사, 형식 추론, 제약\n 형식검사  filter (inventory, (Apple apple) -\u0026gt; apple.getWeight() \u0026gt; 150) //같은 람다, 다른 함수형 인터페이스 Callable\u0026lt;Integer\u0026gt; c = () -\u0026gt; 42; PrivilegedAction\u0026lt;Integer\u0026gt; p = () -\u0026gt; 42;  형식 추론  filter (inventory, (Apple apple) -\u0026gt; apple.getWeight() \u0026gt; 150) filter (inventory, apple -\u0026gt; apple.getWeight() \u0026gt; 150) //Apple 은 생략 가능하다.  제약  람다에서 지역변수는 람다 캡처링에 의해서 final 변수와 동일하게 사용해야 한다.\nint portNumber = 1337; Runnable r = () -\u0026gt; System.out.prinln(portNumber); portNumber = 31337; //컴파일 오류 발생 메서드 참조\n메소드 참조(method reference)는 람다 표현식이 단 하나의 메소드만을 호출하는 경우에 해당 람다 표현식에서 불필요한 매개변수를 제거하고 사용할 수 있다.\ninventory.sort((a1, a2) -\u0026gt; a1.getWeight().compareTo(a2.getWeight)); inventory.sort(comparing(Apple::getWeight)); 생성자 참조\n단순히 객체를 생성하고 반환하는 람다 표현식은 생성자 참조로 변환\nSupplier\u0026lt;Apple\u0026gt; c1 = Apple::new; Supplier\u0026lt;Apple\u0026gt; c1 = () -\u0026gt; new Apple(); Apple a1 = c2.get(); Function\u0026lt;Integer, Apple\u0026gt; c2 = Apple::new; Function\u0026lt;Integer, Apple\u0026gt; c2 = (weight) -\u0026gt; new Apple(weight); Apple a2 = c2.aply(110); 람다 표현식을 조합할 수 있는 유용한 메소드\n Comparator 조합  // 비교를 이용해 Comparator를 반환 Comparator\u0026lt;Apple\u0026gt; c = Comparator.comparing(Apple::getWeight); // 역정렬 inventory.sort(comparing(Apple::getWeight).reversed()); // \u0026lt;- 무게 내림차순으로 정렬  // 연결 inventory.sort(comparing(Apple::getWeight) .reversed() // \u0026lt;- 무게 내림차순으로 정렬 	.thenComparing(Apple::getCountry)); // 두 사과의 무게가 같은면 국가 별로 정렬  Predicate 조합\n//기존 프레디케이트 객체결과를 반전시킨 결과 Predicate\u0026lt;Apple\u0026gt; notRedApple = redApple.negate(); // 두개 연결 Predicate\u0026lt;Apple\u0026gt; redAndHeavyApple = redApple.and(apple -\u0026gt; apple.getWeight() \u0026gt; 150); // 연결해서 복잡한 결과 Predicate\u0026lt;Apple\u0026gt; redAndHeavyApple = redApple.and(apple -\u0026gt; apple.getWeight() \u0026gt; 150) .or(GREEN.equals(a.getColor())); Funtion 조합\nFunction\u0026lt;Integer, Integer\u0026gt; f = x -\u0026gt; x + 1; Function\u0026lt;Integer, Integer\u0026gt; g = x -\u0026gt; x * 5; Function\u0026lt;Integer, Integer\u0026gt; h = f.andThen(g); int result = h.appy(1); //4 반환  Function\u0026lt;Integer, Integer\u0026gt; f = x -\u0026gt; x + 1; Function\u0026lt;Integer, Integer\u0026gt; g = x -\u0026gt; x * 5; Function\u0026lt;Integer, Integer\u0026gt; h = f.compose(g); int result = h.appy(1); //3 반환 "}),a.add({id:3,href:'/docs/java/mordern_java_in_action/part2/',title:"Part2. 함수형 데이터 처리",section:"Mordern Java in Action",content:"Part2. 함수형 데이터 처리 #  4장 스트림 소개 #  스트림이란 무엇인가 Stream 자바 8 API 새로 추가된 기능이다.\n자바 7의 코드\nList\u0026lt;Dish\u0026gt; lowCaloricDishes = new ArrayList\u0026lt;\u0026gt;(); for(Dish dish: menu) { if(dish.getCalories() \u0026lt; 400) { lowCaloricDishes.add(dish); } } Collections.sort(lowCaloricdishes, new Comparator\u0026lt;Dish\u0026gt;() { // 익명 클래스로 요리 정렬  pulbic int compare(Dish dish1, Dish dish2) { return Integer.compare(dish1.getCalories(), dish2.getCalories()); } }); List\u0026lt;String\u0026gt; lowCaloricDishesName = new ArrayList(); for(DIsh dish: lowCaloricDishes) { lowCaloricDishesName.add(dish.getName()); } 자바 8 후의 코드\nimport static java.util.Comparator.comparing; import static java.util.stream.Collectors.toList; List\u0026lt;String\u0026gt; lowCaloricDishesName = menu.stream() //parallelStream 을 사용하면 병렬  .filter(d -\u0026gt; d.getCalories() \u0026lt; 400\u0026gt;) //400 칼로리 미만의 요리 선택  .sorted(comparing(Dishes::getCalories)) // 칼로리로 정렬  .map(Dish::getName) // 요리명 추출  .collect(toList()); // 모든 요리명 리스트에 저장  자바 8 스트림 API 의 특징\n 선언형 : 더 간결하고 가독성이 좋아진다. 조립할 수 있음 : 유연성이 좋아진다. 병렬성 : 성능이 좋아진다.  스트림 시작하기\n데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소 (Squence of element)로 정의할 수 있다.\n 연속 된 요소 소스 데이터 처리 연산  스트림의 주요 특징\n 파이프라이닝 : Laziness, short-circuiting 내부반복  스트림의 주요 기능\n filter : 람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다. map : 람다를 이용해서 한 요소를 다른 요소로 변환하거나 정보를 추출한다. limit: 스트림 크기를 제한한다. collect: 스트림을 다른 형식으로 변환한다.  스트림의 연산\n 중간연산 - 쇼트 서킷, 서로 다른 연산이지만 병합되는 기법 루프 퓨전(loop fusioin) 최종연산  5장 스트림 활용 #  Optional?\nOptional 값의 존재나 부재 여부를 표현하는 컨테이너 클래스\nnull 은 쉽게 에러를 일으킬 수 있으므로 자바 8 라이브러리 설계자는 Optional를 만들었다.\n isPresent(): 값이 있으면 참을 반환한다. T get() : 값이 존재하면 값을 반환하고 없으면 NoSuchElementException을 일으킨다. T orElse(T other): 값이 있으면 값을 반환하고, 값이 없으면 기본값을 반환한다.  findFirst와 findAny 는 언제 사용하나?\n병렬 스트림에서는 첫 번째 요소를 찾기 어렵다. 요소의 순서가 상관없다면 findAny를 사용한다.\n리듀싱 모든 스트림 요소를 반복 처리해서 값으로 도출하는 리듀싱 연산을 한다. 함수형 프로그래밍 언어 용어로는 폴드라고 부른다.\nint sum = 0; for (int x : number) { sum += x; } //초기 값 0 int sum = numbers.stream().reduce(0, ( a,b,) -\u0026gt; a + b); //초기 값 없이 사용 Optional\u0026lt;Integer\u0026gt; sum = numbers.stream().reduce((a,b) -\u0026gt; (a + b)); //최대값 최솟값 Optional\u0026lt;Integer\u0026gt; max = numbers.stream().reduce(Integer::max); Optional\u0026lt;Integer\u0026gt; min = numbers.stream().reduce(Integer::min); 6장 스트림으로 데이터 수집 #  7장 병렬 데이터 처리와 성능 #  "}),a.add({id:4,href:'/docs/java/mordern_java_in_action/part3/',title:"Part3. 스트림과람다...",section:"Mordern Java in Action",content:"Part3. 스트림과 람다를 이용한 효과적인 프로그래밍 #  8장 컬렉션 API 개선 #  컬렉션 팩토리\n적은 요소를 가지고 있는 리스트를 생성\nList\u0026lt;String\u0026gt; friends = Arrays.asList(\u0026#34;Rapheal\u0026#34;, \u0026#34;Olivia\u0026#34;); UnsupportedOperationException 내부적으로 고정된 크기의 변환할 수 있는 배열로 구현 되었기 때문에 발생한다.\n집합을 생성\nSet\u0026lt;String\u0026gt; friends = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;Rapheael\u0026#34;, \u0026#34;Olivia\u0026#34;, \u0026#34;Thibaut\u0026#34;)); 스트림 API 로 집합을 생성\nSet\u0026lt;String\u0026gt; friends = Stream.of(\u0026#34;Raphael\u0026#34;, \u0026#34;Olivia\u0026#34;, \u0026#34;THibat\u0026#34;).collect(Collectors.toSet()); 리스트 팩토리\nList.of() 로 간단한 리스트 생성\nListM\u0026lt;String\u0026gt; friend = List.of(\u0026#34;Raphael\u0026#34;, \u0026#34;Olivia\u0026#34;, \u0026#34;Thibat\u0026#34;); List.of() 로 생성한 리스트에 요소를 추가하거나 변경하려고 하면 UnsupportedOperationException 이 발생한다.\n스트림으로도 리스트를 생성할 수 있다. 데이터 처리 형식을 설정하거나 데이터를 변환할 필요가 없다면 사용하기 편한 팩토리 메서드를 이용할 것을 권장한다.\n집합 팩토리\n집합 팩토리로 집합으로 생성\nSet\u0026lt;String\u0026gt; friends = Set.of(\u0026#34;Raphael\u0026#34;, \u0026#34;Olivia\u0026#34;, \u0026#34;Thibat\u0026#34;); 맵 팩토리\n맵팩토리를 활용하여 생성\nimport java.util.Mpa.entry; Map\u0026lt;String, Integer\u0026gt; ageOfFriends = Mpa.ofEntries(entry(\u0026#34;Raphael\u0026#34;, 30), entry(\u0026#34;Oliva\u0026#34;, 25), entry(\u0026#34;Thibat\u0026#34;, 30)); 리스트와 집합의 처리\n"}),a.add({id:5,href:'/docs/java/javatype/',title:"Primitive type, Reference type",section:"Java",content:"Primitive type, Reference type #  1. 기본형 (Primitive) #   Primitive type은 논리형, 문자형, 정수형, 실수형으로 구분된다. blooean, byte, short, int, long , float, duble, char 8가지 이다. null 이 존재하지 않는다. waper class 가 존재한다. Stack 메모리에 저장된다. 컴파일 시점에 메모리의 크기를 초과하면 에러가 발생한다. (stack over flow)  2. 참조형 (Reference type) #   기본형 타입을 제외한 타입들이 모두 참조형 타입(Reference type)이다. java.lang.Object 상속 null 이 존재하며 어떤 객체 주소도 저장되어 있지 않음을 의미한다. 객체 주소값을 저장 heap 메모리에 저장한다.  자료형(data type) 과 타입(type) 의 차이 #  type 이 더 포괄적인 의미이다. 기본형과 다르게 참조형은 객체의 주소값을 저장하므로 data가 아닌 type 이라는 용어를 사용한다. (자바의 정석 - p.28)\n"}),a.add({id:6,href:'/docs/infra/scale_up_scale_out/',title:"Scale-up, Scale-out",section:"Infra",content:"Scale-up, Scale-out #  스케일업(Scale-up)은 단순히 말하자면 기존의 하드웨어를 보다 높은 사양으로 업그레이드하는 것을 말합니다.\n스케일아웃(Scale-out)은 장비를 추가해서 확장하는 방식을 말합니다.\n시스템 리소스를 확장하는 방법으로는 수평적으로 부하를 분산하는 스케일 아웃(scale out) 방식으로 확장을 할 지 아니면 해당 서버의 용량 자체를 올리는 스케일 업 (scale up) 방식으로 확장을 할지 선택해야 한다.\n"}),a.add({id:7,href:'/docs/java/ect/java_string_method/',title:"String Method",section:"Ect",content:"String Method #  String.IndexOf()\nString.LastIndexOf()\nString.length()\nString.contains()\nString.toCharArray()\nString.replace()\nString.replaceAll()\nString.toLowCase()\nString.toUpperCase()\nString.substring()\n"}),a.add({id:8,href:'/docs/java/ect/javax_valid/',title:"javax @Valid",section:"Ect",content:"javax @Valid #  implementation 'org.springframework.boot:spring-boot-starter-validation' @NotNull : The annotated element must not be null. Accepts any type.\n null 을 허용하지않고 모든 타입에 사용할수 있다. \u0026quot;\u0026quot; 이나 \u0026quot; \u0026quot; 은 허용한다.  @NotEmpty: The annotated element must not be null nor empty\n  null 과 \u0026quot;\u0026quot; 은 허용하지 않는다.\n  \u0026quot; \u0026quot; 은 허용\n  문자열, 콜랙션, 맵, 배열 타입에 활용할 수 있다.\n  CharSequence (length of character sequence is evaluated)\n  Collection (collection size is evaluated)\n  Map (map size is evaluated)\n  Array (array length is evaluated)\n  @NotBlank : The annotated element must not be null and must contain at least one non-whitespace character. Accepts\n null 과 \u0026quot;\u0026quot; 과 \u0026quot; \u0026quot; 모두 허용하지 않는다.  @Null : The annotated element must be null\n null을 허용한다.  출처\nJava EE \n"})})()